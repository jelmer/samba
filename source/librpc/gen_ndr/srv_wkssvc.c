/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_wkssvc.h"

static bool api_wkssvc_NetWkstaGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetWkstaGetInfo *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETWKSTAGETINFO];
	
	r = talloc(NULL, struct wkssvc_NetWkstaGetInfo);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetWkstaGetInfo, r);
	
	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union wkssvc_NetWkstaInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return False;
	}
	
	r->out.result = _wkssvc_NetWkstaGetInfo(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetWkstaGetInfo, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetWkstaSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetWkstaSetInfo *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETWKSTASETINFO];
	
	r = talloc(NULL, struct wkssvc_NetWkstaSetInfo);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetWkstaSetInfo, r);
	
	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _wkssvc_NetWkstaSetInfo(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetWkstaSetInfo, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetWkstaEnumUsers(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetWkstaEnumUsers *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETWKSTAENUMUSERS];
	
	r = talloc(NULL, struct wkssvc_NetWkstaEnumUsers);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetWkstaEnumUsers, r);
	
	ZERO_STRUCT(r->out);
	r->out.users = r->in.users;
	r->out.entriesread = talloc_zero(r, uint32_t);
	if (r->out.entriesread == NULL) {
		talloc_free(r);
		return False;
	}
	
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return False;
	}
	
	r->out.resumehandle = r->in.resumehandle;
	r->out.result = _wkssvc_NetWkstaEnumUsers(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetWkstaEnumUsers, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRWKSTAUSERGETINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRWKSTAUSERGETINFO *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRWKSTAUSERGETINFO];
	
	r = talloc(NULL, struct WKSSVC_NETRWKSTAUSERGETINFO);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRWKSTAUSERGETINFO, r);
	
	r->out.result = _WKSSVC_NETRWKSTAUSERGETINFO(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRWKSTAUSERGETINFO, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRWKSTAUSERSETINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRWKSTAUSERSETINFO *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRWKSTAUSERSETINFO];
	
	r = talloc(NULL, struct WKSSVC_NETRWKSTAUSERSETINFO);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRWKSTAUSERSETINFO, r);
	
	r->out.result = _WKSSVC_NETRWKSTAUSERSETINFO(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRWKSTAUSERSETINFO, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetWkstaTransportEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetWkstaTransportEnum *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETWKSTATRANSPORTENUM];
	
	r = talloc(NULL, struct wkssvc_NetWkstaTransportEnum);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetWkstaTransportEnum, r);
	
	ZERO_STRUCT(r->out);
	r->out.level = r->in.level;
	r->out.ctr = r->in.ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return False;
	}
	
	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _wkssvc_NetWkstaTransportEnum(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetWkstaTransportEnum, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRWKSTATRANSPORTADD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRWKSTATRANSPORTADD *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRWKSTATRANSPORTADD];
	
	r = talloc(NULL, struct WKSSVC_NETRWKSTATRANSPORTADD);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRWKSTATRANSPORTADD, r);
	
	r->out.result = _WKSSVC_NETRWKSTATRANSPORTADD(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRWKSTATRANSPORTADD, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRWKSTATRANSPORTDEL(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRWKSTATRANSPORTDEL *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRWKSTATRANSPORTDEL];
	
	r = talloc(NULL, struct WKSSVC_NETRWKSTATRANSPORTDEL);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRWKSTATRANSPORTDEL, r);
	
	r->out.result = _WKSSVC_NETRWKSTATRANSPORTDEL(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRWKSTATRANSPORTDEL, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRUSEADD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRUSEADD *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUSEADD];
	
	r = talloc(NULL, struct WKSSVC_NETRUSEADD);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRUSEADD, r);
	
	r->out.result = _WKSSVC_NETRUSEADD(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRUSEADD, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRUSEGETINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRUSEGETINFO *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUSEGETINFO];
	
	r = talloc(NULL, struct WKSSVC_NETRUSEGETINFO);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRUSEGETINFO, r);
	
	r->out.result = _WKSSVC_NETRUSEGETINFO(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRUSEGETINFO, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRUSEDEL(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRUSEDEL *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUSEDEL];
	
	r = talloc(NULL, struct WKSSVC_NETRUSEDEL);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRUSEDEL, r);
	
	r->out.result = _WKSSVC_NETRUSEDEL(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRUSEDEL, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRUSEENUM(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRUSEENUM *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUSEENUM];
	
	r = talloc(NULL, struct WKSSVC_NETRUSEENUM);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRUSEENUM, r);
	
	r->out.result = _WKSSVC_NETRUSEENUM(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRUSEENUM, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRMESSAGEBUFFERSEND(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRMESSAGEBUFFERSEND *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRMESSAGEBUFFERSEND];
	
	r = talloc(NULL, struct WKSSVC_NETRMESSAGEBUFFERSEND);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRMESSAGEBUFFERSEND, r);
	
	r->out.result = _WKSSVC_NETRMESSAGEBUFFERSEND(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRMESSAGEBUFFERSEND, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRWORKSTATIONSTATISTICSGET(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRWORKSTATIONSTATISTICSGET *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRWORKSTATIONSTATISTICSGET];
	
	r = talloc(NULL, struct WKSSVC_NETRWORKSTATIONSTATISTICSGET);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRWORKSTATIONSTATISTICSGET, r);
	
	r->out.result = _WKSSVC_NETRWORKSTATIONSTATISTICSGET(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRWORKSTATIONSTATISTICSGET, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRLOGONDOMAINNAMEADD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRLOGONDOMAINNAMEADD *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRLOGONDOMAINNAMEADD];
	
	r = talloc(NULL, struct WKSSVC_NETRLOGONDOMAINNAMEADD);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRLOGONDOMAINNAMEADD, r);
	
	r->out.result = _WKSSVC_NETRLOGONDOMAINNAMEADD(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRLOGONDOMAINNAMEADD, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRLOGONDOMAINNAMEDEL(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRLOGONDOMAINNAMEDEL *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRLOGONDOMAINNAMEDEL];
	
	r = talloc(NULL, struct WKSSVC_NETRLOGONDOMAINNAMEDEL);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRLOGONDOMAINNAMEDEL, r);
	
	r->out.result = _WKSSVC_NETRLOGONDOMAINNAMEDEL(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRLOGONDOMAINNAMEDEL, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRJOINDOMAIN(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRJOINDOMAIN *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRJOINDOMAIN];
	
	r = talloc(NULL, struct WKSSVC_NETRJOINDOMAIN);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRJOINDOMAIN, r);
	
	r->out.result = _WKSSVC_NETRJOINDOMAIN(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRJOINDOMAIN, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRUNJOINDOMAIN(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRUNJOINDOMAIN *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUNJOINDOMAIN];
	
	r = talloc(NULL, struct WKSSVC_NETRUNJOINDOMAIN);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRUNJOINDOMAIN, r);
	
	r->out.result = _WKSSVC_NETRUNJOINDOMAIN(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRUNJOINDOMAIN, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRRENAMEMACHINEINDOMAIN(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRRENAMEMACHINEINDOMAIN *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRRENAMEMACHINEINDOMAIN];
	
	r = talloc(NULL, struct WKSSVC_NETRRENAMEMACHINEINDOMAIN);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRRENAMEMACHINEINDOMAIN, r);
	
	r->out.result = _WKSSVC_NETRRENAMEMACHINEINDOMAIN(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRRENAMEMACHINEINDOMAIN, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRVALIDATENAME(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRVALIDATENAME *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRVALIDATENAME];
	
	r = talloc(NULL, struct WKSSVC_NETRVALIDATENAME);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRVALIDATENAME, r);
	
	r->out.result = _WKSSVC_NETRVALIDATENAME(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRVALIDATENAME, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRGETJOININFORMATION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRGETJOININFORMATION *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRGETJOININFORMATION];
	
	r = talloc(NULL, struct WKSSVC_NETRGETJOININFORMATION);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRGETJOININFORMATION, r);
	
	r->out.result = _WKSSVC_NETRGETJOININFORMATION(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRGETJOININFORMATION, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRGETJOINABLEOUS(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRGETJOINABLEOUS *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRGETJOINABLEOUS];
	
	r = talloc(NULL, struct WKSSVC_NETRGETJOINABLEOUS);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRGETJOINABLEOUS, r);
	
	r->out.result = _WKSSVC_NETRGETJOINABLEOUS(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRGETJOINABLEOUS, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetrJoinDomain2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetrJoinDomain2 *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRJOINDOMAIN2];
	
	r = talloc(NULL, struct wkssvc_NetrJoinDomain2);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetrJoinDomain2, r);
	
	r->out.result = _wkssvc_NetrJoinDomain2(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetrJoinDomain2, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetrUnjoinDomain2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetrUnjoinDomain2 *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRUNJOINDOMAIN2];
	
	r = talloc(NULL, struct wkssvc_NetrUnjoinDomain2);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetrUnjoinDomain2, r);
	
	r->out.result = _wkssvc_NetrUnjoinDomain2(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetrUnjoinDomain2, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetrRenameMachineInDomain2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetrRenameMachineInDomain2 *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRRENAMEMACHINEINDOMAIN2];
	
	r = talloc(NULL, struct wkssvc_NetrRenameMachineInDomain2);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetrRenameMachineInDomain2, r);
	
	r->out.result = _wkssvc_NetrRenameMachineInDomain2(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetrRenameMachineInDomain2, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRVALIDATENAME2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRVALIDATENAME2 *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRVALIDATENAME2];
	
	r = talloc(NULL, struct WKSSVC_NETRVALIDATENAME2);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRVALIDATENAME2, r);
	
	r->out.result = _WKSSVC_NETRVALIDATENAME2(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRVALIDATENAME2, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRGETJOINABLEOUS2(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRGETJOINABLEOUS2 *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRGETJOINABLEOUS2];
	
	r = talloc(NULL, struct WKSSVC_NETRGETJOINABLEOUS2);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRGETJOINABLEOUS2, r);
	
	r->out.result = _WKSSVC_NETRGETJOINABLEOUS2(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRGETJOINABLEOUS2, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetrAddAlternateComputerName(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetrAddAlternateComputerName *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRADDALTERNATECOMPUTERNAME];
	
	r = talloc(NULL, struct wkssvc_NetrAddAlternateComputerName);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetrAddAlternateComputerName, r);
	
	r->out.result = _wkssvc_NetrAddAlternateComputerName(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetrAddAlternateComputerName, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_wkssvc_NetrRemoveAlternateComputerName(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct wkssvc_NetrRemoveAlternateComputerName *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRREMOVEALTERNATECOMPUTERNAME];
	
	r = talloc(NULL, struct wkssvc_NetrRemoveAlternateComputerName);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(wkssvc_NetrRemoveAlternateComputerName, r);
	
	r->out.result = _wkssvc_NetrRemoveAlternateComputerName(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(wkssvc_NetrRemoveAlternateComputerName, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRSETPRIMARYCOMPUTERNAME(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRSETPRIMARYCOMPUTERNAME *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRSETPRIMARYCOMPUTERNAME];
	
	r = talloc(NULL, struct WKSSVC_NETRSETPRIMARYCOMPUTERNAME);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRSETPRIMARYCOMPUTERNAME, r);
	
	r->out.result = _WKSSVC_NETRSETPRIMARYCOMPUTERNAME(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRSETPRIMARYCOMPUTERNAME, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}

static bool api_WKSSVC_NETRENUMERATECOMPUTERNAMES(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	NTSTATUS status;
	DATA_BLOB blob;
	struct WKSSVC_NETRENUMERATECOMPUTERNAMES *r;
	
	call = &ndr_table_wkssvc.calls[NDR_WKSSVC_NETRENUMERATECOMPUTERNAMES];
	
	r = talloc(NULL, struct WKSSVC_NETRENUMERATECOMPUTERNAMES);
	if (r == NULL) {
		return False;
	}
	
	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return False;
	}
	
	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return False;
	}
	
	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	status = call->ndr_pull(pull, NDR_IN, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_IN_DEBUG(WKSSVC_NETRENUMERATECOMPUTERNAMES, r);
	
	r->out.result = _WKSSVC_NETRENUMERATECOMPUTERNAMES(p, r);
	
	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return True here, srv_pipe_hnd.c will take care */
		return True;
	}
	
	if (DEBUGLEVEL >= 10)
		NDR_PRINT_OUT_DEBUG(WKSSVC_NETRENUMERATECOMPUTERNAMES, r);
	
	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return False;
	}
	
	status = call->ndr_push(push, NDR_OUT, r);
	if (NT_STATUS_IS_ERR(status)) {
		talloc_free(r);
		return False;
	}
	
	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32)blob.length)) {
		talloc_free(r);
		return False;
	}
	
	talloc_free(r);
	
	return True;
}


/* Tables */
static struct api_struct api_wkssvc_cmds[] = 
{
	{"WKSSVC_NETWKSTAGETINFO", NDR_WKSSVC_NETWKSTAGETINFO, api_wkssvc_NetWkstaGetInfo},
	{"WKSSVC_NETWKSTASETINFO", NDR_WKSSVC_NETWKSTASETINFO, api_wkssvc_NetWkstaSetInfo},
	{"WKSSVC_NETWKSTAENUMUSERS", NDR_WKSSVC_NETWKSTAENUMUSERS, api_wkssvc_NetWkstaEnumUsers},
	{"WKSSVC_NETRWKSTAUSERGETINFO", NDR_WKSSVC_NETRWKSTAUSERGETINFO, api_WKSSVC_NETRWKSTAUSERGETINFO},
	{"WKSSVC_NETRWKSTAUSERSETINFO", NDR_WKSSVC_NETRWKSTAUSERSETINFO, api_WKSSVC_NETRWKSTAUSERSETINFO},
	{"WKSSVC_NETWKSTATRANSPORTENUM", NDR_WKSSVC_NETWKSTATRANSPORTENUM, api_wkssvc_NetWkstaTransportEnum},
	{"WKSSVC_NETRWKSTATRANSPORTADD", NDR_WKSSVC_NETRWKSTATRANSPORTADD, api_WKSSVC_NETRWKSTATRANSPORTADD},
	{"WKSSVC_NETRWKSTATRANSPORTDEL", NDR_WKSSVC_NETRWKSTATRANSPORTDEL, api_WKSSVC_NETRWKSTATRANSPORTDEL},
	{"WKSSVC_NETRUSEADD", NDR_WKSSVC_NETRUSEADD, api_WKSSVC_NETRUSEADD},
	{"WKSSVC_NETRUSEGETINFO", NDR_WKSSVC_NETRUSEGETINFO, api_WKSSVC_NETRUSEGETINFO},
	{"WKSSVC_NETRUSEDEL", NDR_WKSSVC_NETRUSEDEL, api_WKSSVC_NETRUSEDEL},
	{"WKSSVC_NETRUSEENUM", NDR_WKSSVC_NETRUSEENUM, api_WKSSVC_NETRUSEENUM},
	{"WKSSVC_NETRMESSAGEBUFFERSEND", NDR_WKSSVC_NETRMESSAGEBUFFERSEND, api_WKSSVC_NETRMESSAGEBUFFERSEND},
	{"WKSSVC_NETRWORKSTATIONSTATISTICSGET", NDR_WKSSVC_NETRWORKSTATIONSTATISTICSGET, api_WKSSVC_NETRWORKSTATIONSTATISTICSGET},
	{"WKSSVC_NETRLOGONDOMAINNAMEADD", NDR_WKSSVC_NETRLOGONDOMAINNAMEADD, api_WKSSVC_NETRLOGONDOMAINNAMEADD},
	{"WKSSVC_NETRLOGONDOMAINNAMEDEL", NDR_WKSSVC_NETRLOGONDOMAINNAMEDEL, api_WKSSVC_NETRLOGONDOMAINNAMEDEL},
	{"WKSSVC_NETRJOINDOMAIN", NDR_WKSSVC_NETRJOINDOMAIN, api_WKSSVC_NETRJOINDOMAIN},
	{"WKSSVC_NETRUNJOINDOMAIN", NDR_WKSSVC_NETRUNJOINDOMAIN, api_WKSSVC_NETRUNJOINDOMAIN},
	{"WKSSVC_NETRRENAMEMACHINEINDOMAIN", NDR_WKSSVC_NETRRENAMEMACHINEINDOMAIN, api_WKSSVC_NETRRENAMEMACHINEINDOMAIN},
	{"WKSSVC_NETRVALIDATENAME", NDR_WKSSVC_NETRVALIDATENAME, api_WKSSVC_NETRVALIDATENAME},
	{"WKSSVC_NETRGETJOININFORMATION", NDR_WKSSVC_NETRGETJOININFORMATION, api_WKSSVC_NETRGETJOININFORMATION},
	{"WKSSVC_NETRGETJOINABLEOUS", NDR_WKSSVC_NETRGETJOINABLEOUS, api_WKSSVC_NETRGETJOINABLEOUS},
	{"WKSSVC_NETRJOINDOMAIN2", NDR_WKSSVC_NETRJOINDOMAIN2, api_wkssvc_NetrJoinDomain2},
	{"WKSSVC_NETRUNJOINDOMAIN2", NDR_WKSSVC_NETRUNJOINDOMAIN2, api_wkssvc_NetrUnjoinDomain2},
	{"WKSSVC_NETRRENAMEMACHINEINDOMAIN2", NDR_WKSSVC_NETRRENAMEMACHINEINDOMAIN2, api_wkssvc_NetrRenameMachineInDomain2},
	{"WKSSVC_NETRVALIDATENAME2", NDR_WKSSVC_NETRVALIDATENAME2, api_WKSSVC_NETRVALIDATENAME2},
	{"WKSSVC_NETRGETJOINABLEOUS2", NDR_WKSSVC_NETRGETJOINABLEOUS2, api_WKSSVC_NETRGETJOINABLEOUS2},
	{"WKSSVC_NETRADDALTERNATECOMPUTERNAME", NDR_WKSSVC_NETRADDALTERNATECOMPUTERNAME, api_wkssvc_NetrAddAlternateComputerName},
	{"WKSSVC_NETRREMOVEALTERNATECOMPUTERNAME", NDR_WKSSVC_NETRREMOVEALTERNATECOMPUTERNAME, api_wkssvc_NetrRemoveAlternateComputerName},
	{"WKSSVC_NETRSETPRIMARYCOMPUTERNAME", NDR_WKSSVC_NETRSETPRIMARYCOMPUTERNAME, api_WKSSVC_NETRSETPRIMARYCOMPUTERNAME},
	{"WKSSVC_NETRENUMERATECOMPUTERNAMES", NDR_WKSSVC_NETRENUMERATECOMPUTERNAMES, api_WKSSVC_NETRENUMERATECOMPUTERNAMES},
};

void wkssvc_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_wkssvc_cmds;
	*n_fns = sizeof(api_wkssvc_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_wkssvc_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "wkssvc", "wkssvc", api_wkssvc_cmds, sizeof(api_wkssvc_cmds) / sizeof(struct api_struct));
}
